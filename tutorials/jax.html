
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Thinking in JAX &#8212; cr-sparse  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/custom.js"></script>
    <script src="../_static/js/mathconf.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dirac Cosine Dictionaries" href="dirac_cosine_dictionaries.html" />
    <link rel="prev" title="Tutorials" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">cr-sparse</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=carnotresearch&repo=cr-sparse&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Thinking in JAX</a></li>
<li class="toctree-l2"><a class="reference internal" href="dirac_cosine_dictionaries.html">Dirac Cosine Dictionaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="admm_l1.html">Alternating direction algorithms for l1 problems in compressive sensing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../source/index.html">API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzzreference.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tutorials</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Tutorials</a></li>
      <li>Next: <a href="dirac_cosine_dictionaries.html" title="next chapter">Dirac Cosine Dictionaries</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="thinking-in-jax">
<h1>Thinking in JAX<a class="headerlink" href="#thinking-in-jax" title="Permalink to this headline">¶</a></h1>
<p>JAX API is similar to <cite>NumPy</cite>. However there are
many differences needed to achieve the Just In Time (JIT)
compilation of functions written in JAX.
In this section, we give a set of examples showing
how to write numerical code properly with JAX.</p>
<p>Key points</p>
<ul class="simple">
<li><p>JAX arrays are immutable.</p></li>
<li><p>It should be possible to statically determine
the shape of function output variables from the
shape of input variables for the JIT compiler.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jax.lax</span></code> is a low level module containing
several helper functions to express complex
logic in functional manner. We will often
use its functions in the examples below.</p></li>
<li><p>Standard Python <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> loops cannot be
JIT compiled.</p></li>
<li><p>A Python <code class="docutils literal notranslate"><span class="pre">for</span></code> loop will be
unrolled by JIT compiler (if the iteration count
can be statically determined). This increases
compilation time and should be avoided.</p></li>
<li><p>JAX provides <code class="docutils literal notranslate"><span class="pre">lax.while_loop</span></code> and <code class="docutils literal notranslate"><span class="pre">lax.fori_loop</span></code>
as functional alternatives.</p></li>
<li><p>JAX doesn’t support array views.</p></li>
<li><p>If there are some arguments to a function
which determine the shape of intermediate
arrays in the function body or the output
of the function body, then they must be
marked via <code class="docutils literal notranslate"><span class="pre">static_argnums</span></code> or
<code class="docutils literal notranslate"><span class="pre">static_argnames</span></code> to the JIT compiler.</p></li>
<li><p>The common <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">else</span></code> Python blocks cannot
be JIT compiled. You can use <code class="docutils literal notranslate"><span class="pre">lax.cond</span></code>
or <code class="docutils literal notranslate"><span class="pre">jnp.where</span></code> for building equivalent
logic.</p></li>
</ul>
<p>Sometimes, you may worry that you are writing
too many low level functions just to make the
JIT compiler happy to implement
some logic which could have been done by using
some for/while loops in normal NumPy code.
But this additional complexity pays off in the
end. If the JIT compiler accepts your implementation, it
will generate code which will usually be much
faster than NumPy version.</p>
<p>As we are not used to writing functional code,
it takes a lot of effort to come up with proper
JAX compatible designs in the beginning.
The more you code in JAX, the easier it becomes
to think functionally.</p>
<p>All the code snippets in this tutorial
are taken from the code in <code class="docutils literal notranslate"><span class="pre">CR-Nimble</span></code>
and <code class="docutils literal notranslate"><span class="pre">CR-Sparse</span></code> libraries.</p>
<p>In the following <code class="docutils literal notranslate"><span class="pre">jnp</span></code> is a short name
for <code class="docutils literal notranslate"><span class="pre">jax.numpy</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
</pre></div>
</div>
<p class="rubric">Activating 64-bit mode</p>
<p>By default, JAX uses 32-bit for floating point
numbers. For sparse reconstruction algorithms,
32-bit precision is often not enough.
Do make sure to configure JAX to use 64-bit
floating point numbers before calling any
JAX functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">jax.config</span> <span class="kn">import</span> <span class="n">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_enable_x64&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<section id="d-arrays">
<h2>1D arrays<a class="headerlink" href="#d-arrays" title="Permalink to this headline">¶</a></h2>
<p class="rubric">Modifying vectors</p>
<p>Set a value at a particular index:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Add a value at a particular index:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Subtract a value at a particular index:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">-</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Swapping two elements at index i and j:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xi</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">xj</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Simple checks</p>
<p>Check if a vector contains increasing values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Check if all values in a vector are equal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Basic manipulation</p>
<p>Convert a vector to a row vector (1xn):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert a vector to a column vector (nx1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Construct a unit vector of length n with a zero
in i-th dimension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the length of the array given by
n has to be statically determined by the JIT
compiler.</p>
<p>Right shift the contents of a vector by one element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<ul class="simple">
<li><p>We first construct an array of the same shape
as x containing all zeros.</p></li>
<li><p>We then fill the n -1 elements in this array
(except the first element) with the first n-1
elements of x.</p></li>
<li><p>The last element of x is left out.</p></li>
<li><p>Our focus is on expressing our logic in a functional
manner.</p></li>
<li><p>We leave it to the JIT compiler to come up with
the efficient implementation of the logic for the
target architecture.</p></li>
</ul>
<p>If we want to right shift by n elements, then the logic
becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>Return the magnitudes of elements of a vector
in descending order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>We first get the magnitudes <code class="docutils literal notranslate"><span class="pre">jnp.abs(x)</span></code></p></li>
<li><p>We then sort the result using <code class="docutils literal notranslate"><span class="pre">jnp.sort</span></code> ascending order.</p></li>
<li><p>We finally reverse the array in descending order by indexing
<code class="docutils literal notranslate"><span class="pre">[::-1]</span></code>.</p></li>
</ul>
<p>Let us be more adventurous.
We wish to find out how many of the largest elements
in a vector <code class="docutils literal notranslate"><span class="pre">a</span></code> are enough to capture a fraction <code class="docutils literal notranslate"><span class="pre">q</span></code>
of the total energy of the vector <code class="docutils literal notranslate"><span class="pre">a</span></code>.
The vector can be real or complex. We shall break this
down into multiple steps.</p>
<p>Compute energy of individual elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>
</pre></div>
</div>
<p>Sort the energies in descending order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Compute the total energy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Normalize the energies to fractions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">s</span>
</pre></div>
</div>
<p>Compute the cumulative energies starting from the
largest coefficient:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cmf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Find the index at which the cumulative energy reaches
the required fraction <code class="docutils literal notranslate"><span class="pre">q</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span>  <span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cmf</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>The required number of elements to capture <code class="docutils literal notranslate"><span class="pre">q</span></code>
fraction of energy is <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
<p class="rubric">Conditional code</p>
<p>Consider the following function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">alpha</span>
</pre></div>
</div>
<p>We shall now build this logic using <code class="docutils literal notranslate"><span class="pre">lax.cond</span></code> step by step.
The condition to check is <code class="docutils literal notranslate"><span class="pre">alpha</span> <span class="pre">===</span> <span class="pre">0</span></code>.</p>
<p>We have to define two functions. One for the case where
the condition is true and another for the case where the
condition is false. For both cases, we shall define
anonymous functions using the <code class="docutils literal notranslate"><span class="pre">lambda</span></code> keyword.</p>
<p>Here is the function for the true case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here is the function for the false case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">alpha</span>
</pre></div>
</div>
<p>Both functions take <code class="docutils literal notranslate"><span class="pre">x</span></code> as argument. Now, we can combine
these elements to form our functional equivalent code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lax</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>We suggest you to read the official documentation
to understand the details of <code class="docutils literal notranslate"><span class="pre">lax.cond</span></code>.</p>
<p class="rubric">Circular buffers</p>
<p>A circular buffer is a fixed size array in which one
can push values either left or right side. When
we push a new element, an old element from the
other side is removed.</p>
<p>Assume that we are given a buffer <code class="docutils literal notranslate"><span class="pre">buff</span></code> and
need to push a value <code class="docutils literal notranslate"><span class="pre">val</span></code> from the left side:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">buf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">buf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>If we need to push a value from the right side:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">buf</span><span class="o">.</span><span class="n">at</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="norms">
<h2>Norms<a class="headerlink" href="#norms" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">jnp.linalg.norm</span></code> is the workhorse for
general norm computation. However, we
can often use simple computations for
specific cases ourselves.</p>
<p>Computing the l-1 norm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Computing the l-2 norm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
</pre></div>
</div>
<p>Computing the l-inf norm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">Column wise norms</p>
<p>Often in sparse signal processing, we
are dealing with a matrix consisting
of vectors arranged column wise
where we have to compute the norm of
each vector.</p>
<p>Column-wise l-2 norm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">keepdims=False</span></code> flag is needed to ensure
that the result is reduced to a 1D array.</p>
<p>If we wish to compute the norm along rows, we can just
change <code class="docutils literal notranslate"><span class="pre">axis=1</span></code>.</p>
<p>A common task is normalizing a vector so that it becomes
unit norm. Care must be taken for the case where the
vector is zero.</p>
<p>We can shift the norm value by a very small amount
before carrying out the division. For 32-bit
floating point numbers, the smallest positive value
is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">EPS</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
</pre></div>
</div>
<p>Then normalization can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span> <span class="o">+</span> <span class="n">EPS</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>This approach avoids a conditional expression
using <code class="docutils literal notranslate"><span class="pre">lax.cond</span></code>. It is good to avoid
conditional code as much as possible as
they become bottlenecks (especially when the
numerical code is running on GPU hardware).
Since this normalization is slightly
inaccurate, you should examine the use case
if this inaccuracy is acceptable or not.</p>
</section>
<section id="matrices">
<h2>Matrices<a class="headerlink" href="#matrices" title="Permalink to this headline">¶</a></h2>
<p>Checking if a matrix is symmetric:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>Computing the Hermitian transpose:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Checking if a real matrix has orthogonal columns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>Checking for orthogonal rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">atol</span><span class="p">)</span>
</pre></div>
</div>
<p>Extracting the off-diagonal elements of a matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">jnp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">off_diagonal_elements</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
</pre></div>
</div>
<p>Setting the diagonal elements of a given matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding something to the diagonal elements of a matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Finding the index of the largest element (by magnitude)
in each column of a matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Premultiplying a matrix A with a diagonal matrix
whose diagonal elements are given by a vector d:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">d</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>Post-multiplying a matrix A with a diagonal matrix
whose diagonal elements are given by a vector d:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jnp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>Extracting bxb diagonal blocks from a matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nb</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">b</span>
<span class="n">starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">b</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">)]</span>
<span class="n">blocks</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">starts</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="linear-algebra">
<h2>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h2>
<p class="rubric">Constructing a Toeplitz matrix</p>
<p>A Toeplitz matrix is completely specified by
its first row and column. E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>Suppose we are given the first row and first column
of the Toeplitz matrix and we are required to
construct the whole matrix. We can do so in a
fashion which doesn’t require any loops.
It is achieved by indexing magic.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">toeplitz_mat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="c1"># assert c[0] == r[0]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="c1"># backwards indices</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># forwards indices</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># combine indices for the toeplitz matrix</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="c1"># form the toeplitz matrix</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mat</span>
</pre></div>
</div>
<p>We combined the first row and first column
elements into a single array w. Then constructed
an index matrix where each element in the index
matrix is an index in the w array identifying the
element to be placed in the output Toeplitz matrix.
Forming the Toeplitz matrix then becomes a simple
indexing step.</p>
</section>
<section id="basic-signal-processing">
<h2>Basic Signal Processing<a class="headerlink" href="#basic-signal-processing" title="Permalink to this headline">¶</a></h2>
<p>Scaling a vector to the range 0 and 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shift</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">shift</span>
<span class="n">scale</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">scale</span>
</pre></div>
</div>
<p>Reverting back:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">scale</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">shift</span>
</pre></div>
</div>
<p>Hard thresholding to K largest elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="o">-</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">x_I</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>
</pre></div>
</div>
<p>Here the tuple of <code class="docutils literal notranslate"><span class="pre">(I,</span> <span class="pre">x_I)</span></code> identifies
the indices and values of K largest entries.
To build the full length approximation, we will have
to do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x_I</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, we can do the following
to compute the K sparse approximation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">[:</span><span class="o">-</span><span class="n">K</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Sliding windows</p>
<p>A common signal processing task is to
divide a signal x into windows of length
w each such that consecutive windows
have an overlap of m samples.
Achieving this in JAX will require some indexing trick
again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">step</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="n">m</span>
<span class="n">starts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">block</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">windows</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</pre></div>
</div>
<p>This constructs the windows of x in each row
of the resulting matrix. If you wish the
windows to be column wise, just take the
transpose.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, CR-Suite Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/tutorials/jax.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/carnotresearch/cr-sparse" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-214289683-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>